## new的过程

## 类的加载过程
	连接
加载-验证（文件格式验证，字节码验证，元数据验证）-准备（为类的静态变量分配内存，并将其初始化为默认值）-解析（把类中的符号引用转换为直接引用）-初始化（为类的静态变量赋予正确的初始值）-使用
## 双亲委派模型
优点：共享，隔离（避免重复加载）

## 垃圾收集器

收集器	|串行、并行or并发	|新生代/老年代	|算法	|目标	|适用场景
:---:|:---:|:---:|:---:|:---:|:---:
Serial|	串行	|新生代|	复制算法|	响应速度优先|	单CPU环境下的Client模式
Serial Old|	串行	|老年代|	标记-整理|	响应速度优先	|单CPU环境下的Client模式、CMS的后备预案
ParNew	|并行|	新生代|	复制算法|	响应速度优先|	多CPU环境时在Server模式下与CMS配合
Parallel Scavenge|	并行|	新生代|	复制算法	|吞吐量优先|	在后台运算而不需要太多交互的任务
Parallel Old|	并行	|老年代|	标记-整理|	吞吐量优先|	在后台运算而不需要太多交互的任务
CMS	|并发|	老年代|	标记-清除|	响应速度优先|	集中在互联网站或B/S系统服务端上的Java应用
G1	|并发|	both|	标记-整理+复制算法|	响应速度优先|	面向服务端应用，将来替换CMS

G1 CMS的区别：

- CMS ：并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除）、重置。
- G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）
- CMS 的缺点是对 CPU 的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求。
- CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小。
- G1 和 CMS 都是响应优先把，他们的目的都是尽量控制 STW 时间。

## 堆内存分配
空间|		倍数
:---:|:---:|
总大小|	3-4 倍活跃数据的大小
新生代|	1-1.5 活跃数据的大小
老年代|	2-3 倍活跃数据的大小
永久代|	1.2-1.5 倍Full GC后的永久代空间占
> 活跃数据大小： 应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小 

如何选择各分区大小应该依赖应用程序中对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大