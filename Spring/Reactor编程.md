# Reactor编程

反应式编程本质上是函数式的和声明式的。相对于描述一组将依次执行的步骤，反应式编程描述了数据将会流经的管道或者流。

虽然水气球（或者命令式编程）没有什么固有的问题，但是持有软管（或者能够应用反应式编程）的人通常在伸缩性和性能方面更具优势。

反应式流（Reactive Streams）是由Netflix、Lightbend和Pivotal（Spring背后的公司）的工程师于2013年年底开始制定的一种规范。反应式流旨在提供**无阻塞回压的异步流处理标准**。

## Java的流和反应式流

Java的流和反应式流之间有很多相似之处。首先，它们的名字中都有流（Stream）这个词。它们还提供了用于处理数据的函数式API。事实上，正如你稍后将会在我们介绍Reactor时看到的那样，它们甚至可以共享许多相同的操作。Java的流通常都是同步的，并且只能处理有限的数据集。从本质上来说，它们只是使用函数来对集合进行迭代的一种方式。反应式流支持异步处理任意大小的数据集，同样也包括无限数据集。只要数据就绪，它们就能实时地处理数据，并且能够通过回压来避免压垮数据的消费者。

反应式流规范可以总结为4个接口：Publisher、Subscriber、Subscription和Processor。Publisher负责生成数据，并将数据发送给Subscription（每个Subscriber对应一个Subscription）。

Publisher接口声明了一个方法subscribe()，Subscriber可以通过该方法向Publisher发起订阅。

一旦Subscriber订阅成功，就可以接收来自Publisher的事件。这些事件是通过Subscriber接口上的方法发送的.

Subscriber可以传入一个long类型的数值以表明它愿意接受多少数据。这也是回压能够发挥作用的地方

至于Processor接口，它是Subscriber和Publisher的组合,
当作为Subscriber时，Processor会接收数据并以某种方式对数据进行处理。然后它会将角色转变为Publisher，并将处理的结果发布给它的Subscriber

反应式流规范的接口本身并不支持以函数式的方式组成这样的流。Reactor项目是反应式流规范的一个实现，提供了一组用于组装反应式流的函数式API。

虽然这个反应式的例子看起来依然保持着按步骤执行的模型，但实际是数据会流经处理管线。在处理管线的每一步，都对数据进行了某种形式的加工，但是我们不能判断数据会在哪个线程上执行操作。它们既可能在同一个线程，也可能在不同的线程。

Reactor项目实现了反应式流规范，将反应式流的定义抽象为两个主要的类型，即Flux和Mono，并为每种类型都提供数百个操作

这个例子中的Mono是Reactor的两种核心类型之一，另一个类型是Flux。两者都实现了反应式流的Publisher接口。Flux代表具有零个、一个或者多个（可能是无限个）数据项的管道。Mono是一种特殊的反应式类型，针对数据项不超过一个的场景，它进行了优化

Spring 5利用Reactor提供了反应式控制器、repository、REST客户端以及其他反应式框架的支持
