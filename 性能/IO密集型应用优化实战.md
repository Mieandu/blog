# IO密集型应用线程数优化实战

## 背景

公司基于企业微信的外部联系人功能对客户进行管理，门店员工对客户的添加和打标等信息需要同步到数据中心做进一步的用户画像分析提高营销效率。因为业务需要，我们每天晚上
要从企业微信全量同步一次外部联系人，现在接近50多万客户，全部同步完需要3个小时左右（根据网络状况而波动），按照我们每天几千人左右的客户增长速率，马上同步时间将满足不了业务的需求，此次优化就是针对同步功能来进行的，目标是在不升级服务器的同时将时间压缩到1个半小时左右。

## 优化思路

之前已经做过一次优化将同步效率提升了将近20倍，这里讲一下优化思路：
1.数据库索引优化。索引可以减小数据库操作的响应时间
2.减少不必要的事务。事务带来数据一致性的同时也会消耗一定的性能，在同步过程中基本不会涉及到数据一致性的问题，所以把事务都去掉是没有问题的
3.减少I\O。I\O分为磁盘I\O和网络I\O,像Web项目一般网络I\O居多，这个需要根据业务去优化，比如说减少数据库I\O,用空间换时间也是一种思路
4.多线程同步。针对当前场景大数据量集合的处理，使用多线程同步效果是最明显的了。

通过以上的优化之后，这次优化的主要目的是找到一个线程池数量的最佳值，因为我们这个功能几乎是纯I\O，所以是完全可以大量增加线程的数量来减同步时间，之前是根据经验使用的是5N=10。

## 优化过程

**硬件环境**：

使用的是自己配的主机：

- CPU : AMD Ryzen 7 2700X (八核处理器)
- 内存 ：16G
- 网络：200M带宽

### 计算线程数

首先根据公式 `线程数 = CPU核心数 * （1-阻塞系数）` 计算出参照线程，其中：

**CPU核心数**=8

`阻塞系数 = CPU运行时间/CPU等待时间` （这个是需要测试才能得出的）

使用的JProfiler针对等待时间和运行时间进行测试得出的结果计算出阻塞系数约等于0.02，得出线程数是400，如果我们希望CPU使用率是50%的话，可以设置200个线程来执行同步任务，接下来开始测试。

### 测试同步结果

1. 因为服务器只有2核，所以我们使用200/4 = **50**个线程来进行同步

    使用**50线程**同步完结果：**749秒**

2. 带着好奇心试了下**60线程**会不会将时间缩短1/5

    使用**60线程**同步完结果：**678秒**

3. 额，差距不大，那再试下**40线程**会不会增加耗时

    使用**40线程**同步完结果：**653秒**

时间并没减少，这和想像中的不一样啊，增减线程对结果并没有明显的影响，那是什么影响了同步结果呢？

通过Jprofiler性能统计再三观察终于找到了原因，调用企业微信接口的方法响应时间增加了，并且线程越多响应时间越长。为什么响应时间会随着线程数增加呢？这就是个值得深究的问题。

后面通过观察同步过程中运行的线程状况，发现有大量等待，并且有阻塞现象，如图

打印线程堆栈并查看：

通过堆栈我们可以看到大量的线程在等待获取HttpClient连接池中的连接,这意味着连接数不够，通过查看底层框架的文档得知，线程池中默认的连接数只有10个，确实太小了，一不做二不休直接调大到400。

测试结果：356

同步时间减少了将近一半，而且状态图也如下所示，

可以看到业务线程基本都在执行网络I\O，而不是等待和竞争资源所引起的阻塞，看着这状态图真的舒服了。
![正常](https://github.com/Mieandu/blog/blob/master/%E5%85%B6%E5%AE%83/image/zc.png?raw=true)
根据5w数据同步完成的时间可以推测出同步完所有数据将只要1个小时，已经完成定好的目标了。后面将项目放到测试环境上进行测试，发现同步完所有50w数据只花费了半个小时多一点点，简直不要太完美，可以想到之所以效果这么好是测试环境和数据库处于同一个内网，网络延时更低，操作数据更快了。

至此优化完成，结果非常满意。

## 总结

通过上面的一系列测试，可见影响同步结果的因素有很多（网络延时、线程池连接数、数据库连接数），而且这些因素会相互影响，所以我们在做优化过程中需要耐心去寻找每一个瓶颈点然后进行优化，反复测试，来达到一个理想的结果。不过也不必过于追求完美的结果，满足业务需要即可啦。
