
## 什么时候需要优化
响应时间过长、负载过高
（链路监控）
##诊断：
- **cpu** Load Average （正常：小于0.7*CPU个数）、 CPU使用率、上下文切换次数
> 相关命令：top、 vmstat
- **Memory** virtual= swap + res swap应尽量小
> 相关命令:ps、top
- **I/O** I/O wait
> 相关命令 iostat
## Java应用诊断
- 应用代码诊断：找到耗时长的线程，进行排查
>   top -H -p + jstack
- gc诊断 10s一次minorGC 尽量不要出现FullGC
> jmap jstat mat
###1.代码性能优化
总结：

1. 空间换时间：使用内存或者磁盘，换取更宝贵的CPU 或者网络，如缓存的使用；
1. 时间换空间：通过牺牲部分 CPU，节省内存或者网络资源，如把一次大的网络传输变成多次；
1. 其他诸如并行化（多线程）、异步化、池化技术（资源复用）等。

最佳线程数目 = （（线程等待时间 + 线程 CPU 时间）/ 线程 CPU 时间 ）* CPU 数目

避免事务过长
使用更高效的算法或方案实现
缓存
空间换使时间，避免io
分治

####异步
**使用场景**

针对某些客户端的请求，在服务端可能需要针对这些请求做一些附属额外的事情，这些事情其实用户并不关心或者不需要立即拿到这些事情的处理结果，这种情况就比较适合用异步的方式去处理。
###实现方式
1、线程（线程池）

采用额外开辟一个线程或者使用线程池的做法，在IO线程（处理请求响应）之外的线程来处理相应的任务，在IO线程中让response先返回。

如果异步线程处理的任务设计的数据量非常大，那么可以引入阻塞队列BlockingQueue作进一步的优化。具体做法是让一批异步线程不断地往阻塞队列里添加要处理的数据，然后额外起一个或一批处理线程，循环批量从队列里拿预设大小的数据，来进行批处理，这样进一步提高了性能。

2、消息队列（MQ）

使用消息队列（MQ）中间件服务，MQ天生就是异步的。一些额外的任务，可能不需要这个系统来处理，但是需要其他系统来处理。这个时候可以先把它封装成一个消息，扔到消息队列里面，通过消息中间件的可靠性保证把消息投递到关心它的系统，然后让其他系统来做相应的处理。
避免嵌套循环




####NoSQL

NoSQL和缓存的区别
这里介绍的NoSQL和缓存不一样，虽然可能会使用一样的数据存储方案（比如Redis或者Tair），但是使用的方式不一样，这一节介绍的是把它作为DB来用。如果当作DB来用，需要有效保证数据存储方案的可用性、可靠性。

使用场景
需要结合具体的业务场景，看这块业务涉及的数据是否适合用NoSQL来存储，对数据的操作方式是否适合用NoSQL的方式来操作，或者是否需要用到NoSQL的一些额外特性（比如原子加减等）。

如果业务数据不需要和其他数据作关联，不需要事务或者外键之类的支持，而且有可能写入会异常频繁，这个时候就比较适合用NoSQL（比如HBase）。监控类、日志类系统通常会采集大量的时序数据，这类时序指标数据往往都是“读少写多”的类型，可以使用Elasticsearch、OpenTSDB等。


####多线程与分布式

使用场景：
离线任务、异步任务、大数据任务、耗时较长任务的运行，适当地利用，可达到加速的效果。

注意：线上对响应时间要求较高的场合，尽量少用多线程，尤其是服务线程需要等待任务线程的场合（很多重大事故就是和这个息息相关），如果一定要用，可以对服务线程设置一个最大等待时间。

常见做法
如果单机的处理能力可以满足实际业务的需求，那么尽可能地使用单机多线程的处理方式，减少复杂性；反之，则需要使用多机多线程的方式。

对于单机多线程，可以引入线程池的机制，作用有二：

1）  提高性能，节省线程创建和销毁的开销。

2）  限流，给线程池一个固定的容量，达到这个容量值后再有任务进来，就进入队列进行排队，保障机器极限压力下的稳定处理能力在使用JDK自带的线程池时，一定要仔细理解构造方法的各个参数的含义，如core pool size、max pool size、keepAliveTime、worker queue等，在理解的基础上通过不断地测试调整这些参数值达到最优效果。

如果单机的处理能力不能满足需求，这个时候需要使用多机多线程的方式。这个时候就需要一些分布式系统的知识了，可以选用一些开源成熟的分布式任务调度系统如xxl-job。
####JVM优化

####Java集合的最佳实践
- 基于应用的需求来选择使用**正确类型的集合**，这对**性能**来说是非常重要的。例如，如果元素的大小是固定的，并且知道优先级，我们将会使用一个 Array ，而不是 ArrayList 。
- 一些集合类允许我们指定他们的**初始容量**。因此，如果我们知道存储数据的大概数值，就可以避免重散列或者大小的调整。
- 总是使用**泛型来保证类型安全，可靠性和健壮性**。同时，使用泛型还可以避免运行时的 ClassCastException 异常。
- 在 Map 中使用 JDK 提供的不可变类作为一个 key，这样可以避免 hashcode 的实现和我们自定义类的 equals 方法。
- 应该依照接口而不是实现来编程。
- 返回零长度的集合或者数组，而不是返回一个 null ，这样可以防止底层集合是空的。



2.数据库优化
索引
简单sql
事务拆分
将排序等耗费cpu的操作放到服务层做

结构优化，数据库垂直拆分、水平拆分

###硬件升级
###搜索引擎
###业务逻辑优化
###缓存化
###服务化
###异步化