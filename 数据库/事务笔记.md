事务简介
事务的本质：锁和并发
优势：容易理解
劣势：性能较低
阿里DRDS

事务单元之间的Happen-before关系
写写 写读 读写 读读

实现事务单元之间并发的方式：

- 排队法 （序列化）
优势-不需要冲突控制
劣势-慢速设备

- 排他锁 
 
  	有可能发生冲突，串行

	不会产生冲突，则并行

- 读写锁（RR）

- MVCC
本质 copy on write
能够做到写不阻塞读

事务处理常见问题

事务谁先谁后？
一个读请求应该读哪一个写之后的数据？
逻辑时间戳（自增ID）
scn(Oracle)
trx_id(Innodb)

事务处理-故障恢复

可能的错误情况
	业务属性不匹配
	系统崩溃 （系统重启之后会进入recover状态，）
事务处理-死锁与死锁监测
死锁产生的原因：
	两个线程
	不同方向
	相同资源
死锁解决方案
	尽可能不死锁
	碰撞检测（主流，检测到死锁，则中断其中一个事务）
	等锁超时


分布式事务：
Google Spanner赏析
阿里的分布式事务模型

单机事务：
ACID
- 原子性：
通过undo日志来回滚
- 一致性：保证能看到系统内的所有更改
强一致性通过锁来保证Can（Happen before）

单机事务的典型异常应对策略
回滚
系统down机 

- 隔离性： 

核心目的：提升并行度

以性能为理由，对一致性的破环

 - 序列化读写（排他锁）
 - 读写锁
 	- 可重复读
	 	- 读锁不能被写锁升级
	 	- 读读可并行
 	- 读已提交
		- 读锁能被写锁升级
			读读并行  读写并行
	- 读未提交
		- 只加写锁，读不加锁
	  	读写并行 读读并行 写读并行
- 隔离性扩展
	- 快照
		- 针对读多写少的场景
		- 并行度能达到或超过读未提交，而隔离级别很高
	- 多版本并发控制
		- 乐观锁并发方案：让版本低的并发更新回滚
	核心思路
		copy on write
		无锁编程

- 持久性： 事务提交之后，数据就不会丢失
	RAID的持久性
		1.提交请求到内存后返回
		2.将内存的数据打包到磁盘上，组提交进一步提升延迟，需要考虑iops和吞吐量的协调
	持久性 延迟
	

事务的调优原则
- 在不影响业务应用的前提下，减少锁的覆盖范围
	myisam表锁 -> Innodb行锁
	原位锁 -> MVCC
- 尽可能让更多线程并发访问数据
- 选择正确的锁类型
	-悲观锁 冲突严重
	-乐观锁 冲突不严重


死锁扩展-U锁

分布式事务：
目标：像传统单机事务
事务：多步操作

网络带来的（去中心化）： 高扩展、无限的数据安全、高可用
网络失去的： 
确定性丧失、
	超时到底使成功还是失败
共享数据困难
	共享数据会导致系统有瓶颈
更多的延迟
	光速并不是无限的
并发编程难度上升




分布式事务：
	谁来负责跨机提交？
	网络不可达怎么处理？

协调器（默认第一台提交的机器）
	协调器高可用
	延迟变大
难点
	事务延迟变大（相应的增加了锁的维持时间）
		事务异常处理
		日志记录
	MVCC的顺序问题（逻辑时间戳的单机问题，没有办法实现分布式事务的MVCC）

##总结
在mysql中，提供了两种事务隔离技术，第一个是mvcc，第二个是next-key技术。这个在使用不同的语句的时候可以动态选择。不加lock inshare mode之类的就使用mvcc。否则使用next-key。mvcc的优势是不加锁，并发性高。缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。同时需要注意几点：1.事务的快照时间点是以第一个select来确认的。所以即便事务先开始。但是select在后面的事务的update之类的语句后进行，那么它是可以获取后面的事务的对应的数据。2.mysql中数据的存放还是会通过版本记录一系列的历史数据，这样，可以根据版本查找数据。


##分布式事务

###XA方案
这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为**严重依赖于数据库层面来搞定复杂的事务**，效率很低，绝对不适合高并发的场景

这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在**微服务**，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求**每个服务只能操作自己对应的一个数据库**。

###TCC
TCC 模型是把锁的粒度完全交给业务处理，它需要每个子事务业务都实现Try-Confirm / Cancel 接口。

> ps TCC 模式本质也是 2PC ，只是 TCC 在应用层控制。

- Try:
	- 尝试执行业务
	- 完成所有业务检查（一致性）
	- 预留必须业务资源（准隔离性）
- Confirm:
	- 确认执行业务；
	- 真正执行业务，不作任何业务检查
	- 只使用Try阶段预留的业务资源
	- Confirm 操作满足幂等性
- Cancel:
- 取消执行业务
- 释放Try阶段预留的业务资源
- Cancel操作满足幂等性

TCC 模型对业务的侵入强，改造的难度大。

### 本地消息表
严重依赖于数据库的消息表来管理事务，高并发场景下不好扩展

1.第一张表重试和确认
2.第二张表为了避免重复消费
### 可靠消息最终一致性方案
1. A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；
1. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；
1. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
1. mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。
1. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。