# 并发插入引起死锁问题的深入剖析

## 业务背景

从企业微信进行外部联系人同步需要根据外部联系人ID获取添加了该外部联系人的所有成员，并且将添加时间等信息保存到数据库，因为同步的过程中可能产生并发的情况，为了保证数据的唯一性，需要进行唯一性校验，并且使用了事务，然而在同步的过程中竟然发现插入数据的过程中有死锁的情况，纳尼！！！ 死锁？？？一看这个问题就不简单，好久没碰到难题的我就跟打了鸡血一样，撸起袖子就开干，花了一天多的时间终于把这个问题的来龙去脉搞清楚了

## 场景还原

```sql
// 创建测试表
create table t_lock_test
(
    id  int(255) not null primary key,
    age int(20)  null
);

create index idx_age
    on t_lock_test (age);

```

|序号|事务1|事务2|
|---|---|---|
|1|begin; select * from t_lock_test where age = 1 lock in share mode; ||
|2||begin; select * from t_lock_test where age = 2 lock in share mode;|
|3|insert into t_lock_test values(1,1);||
|4||insert into t_lock_test values(1,2);|
|5||Result:[error]Deadlock found when trying to get lock; try restarting transaction|
|6|commit; ||
|7|Result: success|

## 死锁原因分析

InnoDB存储引擎实现了如下两种标准的行级锁：

- 共享锁（S Lock），允许事务读一行数据。
- 排他锁（X Lock），允许事务删除或更新一行数据。

| |X|S|
|---|---|---|
X|冲突|冲突|
S|冲突|兼容的|

3种行锁算法：

- Record Lock：单个行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。值得注意的是间隙锁的唯一目的是防止其他事务插入间隙。间隙锁可以共存。一个事务进行的间隙锁定不会阻止另一事务对相同的间隙进行间隙锁定。共享间隙锁和排他间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。
- Next-key Lock: 锁定一个范围，并且包含记录本身

举个例子，如果在上述表（t_lock_test）里，age有1，3，5三个值那么Next-key Lock锁定的范围是：

```math
(-∞,1]
(1,3]
(3,5]
(5,+∞)
```

### 查询和更新（增改删）锁的差异

查询分表中有没有记录两种情况：

如果表没有记录，查询的锁不会冲突；但是会对primary索引的 supremum pseudo-record加上Gap锁

> supremum pseudo-record :相当于比索引中所有值都大，但却不存在索引中，相当于最后一行之后的间隙锁

如果表中有记录，当条件中是固定值时，没有命中索引，查询的锁不会冲突，但是会对索引加上Gap锁。

条件中是范围查询时，会对索引加上gap锁，但是有个比较奇怪的现象，我一直不解，翻遍资料也没有找到答案。如果表中只有1条记录两个事务查询范围重叠并且加排它锁会产生冲突。多于两条记录时，查询范围大于最大的索引即使加上排它锁也不会产生冲突，不过gap锁依然存在，会影响到插入。

#### 插入意图锁

插入意图锁是一种通过INSERT行插入之前的操作设置的间隙锁 。此锁发出插入意图的信号是，如果多个事务未插入间隙中的相同位置，则无需等待插入到同一索引间隙中的多个事务

到这里死锁原因就比较明确了，因为表中一开始没有记录，所以加大了插入时候的锁冲突，出现了ABBA的死锁情况，产生了死锁。

## 解决方案

方案1：事务隔离级别降到READ COMMITTED ,Gap Lock将不会生效。
方案2：insert into t3(xx,xx) on duplicate key update `xx`='XX';
用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。

## 总结

凡是都要多折腾，这个问题很早以前就存在，由于数据量太大加上只有表初始化的时候才容易暴露，之前一直没有发现，还是在做数据库分表方案的时候偶然发现的，真是不容易。
