#Redis
- **优点**：
1.速度快
2.支持丰富的数据类型
3.丰富的特性
订阅发布
key过期策略
事务
支持多个db
4.持久化
5.高可用
- **缺点** 
	- 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务
## 持久化：
- **RDB**：
冷备，恢复快，性能最大化（fork子进程之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了）
- **AOF**：
更高的数据安全性；append模式，速度快，出现宕机也不会影响已有的内容；
aof记录的是所有的修改操作

**RDB和AOF的选择**：

bgsave 做镜像全量持久化（从），AOF 做增量持久化(主，从也可以)。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使**用 bgsave 持久化文件**重新构建内存，再使**用 AOF 重放近期的操作指令**来实现完整恢复重启之前的状态。

> bgsave 操作后，会产生 RDB 快照文件
> 为什么不建议在主节点开启RDB？
> 子进程 fork 相关的阻塞；内存相关的阻塞；CPU 单线程相关的阻塞，如果显示绑定了CPU ，则子进程会与主进程共享一个 CPU（持久化则不要绑定CPU）；磁盘相关的阻塞（内存不够的情况）

##过期策略：
懒过期；定期过期；
##淘汰策略：
Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。

Redis 提供了 6 种数据淘汰策略：

1. volatile-lru
1. volatile-ttl
1. volatile-random
1. allkeys-lru
1. allkeys-random
1. 【默认策略】no-enviction

在 Redis 4.0 后，基于 LFU（Least Frequently Used）最近最少使用算法，增加了 2 种淘汰策略：

volatile-lfu
allkeys-lfu


Redis实现分布式锁的方案
1.单机 setnx
2.多机 使用redlock算法

>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。
>
从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。











## Redis 有哪些数据结构？

如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：

字符串 String
字典Hash
列表List
集合Set
有序集合 SortedSet
如果你是 Redis 中级玩家，还需要加上下面几种数据结构：

HyperLogLog
Geo
Bitmap
如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：

BloomFilter
RedisSearch
Redis-ML
JSON
另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。

###Redis为什么这么快的另类解释
面试官：redis作为缓存大家都在用，那redis一定很快咯？


我：当然了，官方提供的数据可以达到100000+的QPS（每秒内的查询次数），这个数据不比Memcached差！


面试官：redis这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）


我：您是想问Redis这么快，为什么还是单线程的吧。Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。


面试官：嗯，是的。那你能说说Redis是单线程的，为什么还能这么快吗？


我：可以这么说吧。第一：Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。第二：数据结构简单，对数据操作也简单。第三：采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。第四：使用多路复用IO模型，非阻塞IO。

