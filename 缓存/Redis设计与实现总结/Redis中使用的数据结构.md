# Redis中使用的数据结构

## 链表

链表提供了高效的节点重排能力，以及顺序行的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。

链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等

### 列表的数据结构

Redis链表特点：

- 双端 ：链表节点带有 prev 和 nex t 指针 ，获取某个节点的前置节点和后置节点的 复杂度都是 0(1）。
- 无环 ：表头节点的 prev  指针和表尾节点的 nex t 指针都指向 N U LL ，对链表的访 问以 NULL    为终点。
- 带表头指针和表尾指针 ：通过 l ist 结构的 head 指针和 t a il 指针 ，程序获取链 表的表头节点和表尾节点 的复杂度为 0(1）。
- 带链表长度计数器 ：程序使用lis t 结构的 len 属性来对 list 持有的链表节 点进 行计数 ，程序获取链表中节点数量的复杂度为  0(1）。
- 多态 ：链表节点使用 vo id＊ 指针来保存节点值 ，并且可以通过 lis t 结构的 du p 、f ree 、ma t ch 三个属性为节点值设置类型特定函数 ，所以链表可以用于保存各种不 同类型的值。

## 字典

字典 ，又称为符号表 （ symbol table ）、关联数组 （ associative array ） 或映射 （ map ），是 一种用于保存键值对 （ key-value pair ） 的抽象数据结构 。

在字典中 ，一个键 （ key ） 可以和一个值 （ value ） 进行关联 （ 或者说将键映射为值 ）， 这些关联的键和值就称为键值对 。
字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值   ，或者通 过键来更新值 ，又或者根据键来删除整个键值对

字典被广泛用与实现Redis的各种功能，其中包括数据库和哈希键

### 字典的数据结构

1. 构造一个dictEntry节点
2. 计算键的hash值，对sizemask取余，计算索引
3. 如果数组索引位置没有节点，则放入节点，有值表示hash冲突，哈希表使用链地址法来解决键冲突 ，被分配到同一个索引上的多个键值对会连接成 一个**单向链表**。将索引位置指针指向当前节点，当前节点的next指针指向原节点。

#### rehash

随着操作的不断执行 ，哈希表保存的键值对会逐渐地增多或者减少 ，为了让哈希表的负 载因子 （ load factor ） 维持在一个合理的范围之内 ，当哈希表保存的键值对数量太多或者太 少时，程序需要对哈希表的大小进行相应的扩展或者收缩  

扩展条件：

1. 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子>=1时
2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子>=5时

缩容条件：
当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行缩容操作

字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用

rehash过程:

1. 为ht[1]分配空间
    > 扩容时，将分配**大于ht[0].used 最小2^（n+1）**的大小，缩容时，将分配**大于ht[0].used最小2^n**的大小
2. 将ht[0]中的元素rehash至ht[1]
3. 释放ht[0]表的空间，将ht[0]指向ht[1],为ht[1]分配空表

在对哈希表进行扩展或者收缩操作时，程序需要将 现有哈希表包含的所有键值对 rehash 到新哈希表里面，并且这个 rehash 过程并不是一次性地完成的 ，而是渐进式地完成的。这种分而治之的方式，从而避免了集中式rehash带来的庞大计算量。

渐进式rehash步骤：

1. 为ht[1]分配空间
2. 在字典中维护一个索引计数变量rehashidx,并将它的值设为0，表示rehash正式开始
3. 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，除了执行指定操作外，还会将ht[0]哈希表rehashidx索引上的所有键值对rehash到ht[1],当rehash完成之后，程序会对rehashidx属性的值增1
4. 随着字典操作的不断执行，最终在某个时间点，ht[0]上的键值对全部rehash至ht[1],这时程序将rehashidx属性的值设为-1，表示rehash操作已经完成。

> 渐进式rehash期间，字典的删除、查找、更新会在两张表上进行，新增只会在ht[1]上进行，这一措施保证l了ht[0]包含的额键值对数量会只减不增，并随着rehash操作的执行最终变成空表

当字典被用作数据库的底层实现 ，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值 。

## 跳跃表

跳跃表 （ skiplist ） 是一种有序数据结构 ，它通过在每个节点中维持多 个指向其他节点的 指针 ， 从而达到快速访 问节点的目的。

### 跳跃表的底层实现

 跳跃表是有序集合的底层实现之 一。
口 Red.is 刷版表实现由 zskiplist 和 zskiplistNode 两个结构组成，其中zskiplis t 用于保存跳跃表信息 （ 比如表头节点、表尾节点、长度），而 zskiplistNode 则用于表 示跳跃表节点。
口 每个跳跃表节点的层高都是 1至 32 之间的随机数。
口 在同一个跳跃表中 ，多个节点可以包含相同的分值 ，但每个节点的成员对象 必须是 唯一的。
口 跳跃表中的节点按照分值大小进行排序 ，当分值相同时 ，节点按照成员对象的大小 进行排序 。

## 整数集合

整数集合 （ intset ） 是集合键的底层实现之一 ，当一个集合只包含整数值元素 ， 并且这 个集合的元素数量不多 时，Redis 就会使用整数集合作为集合键的底层 实现。

### 整数的底层实现

整数集合的底层实现为数组 ，这个数组以有序 、无重复的方式保存集合元素 ，在有 需要时，程序会根据新添加元素的类型，改变这个数组的类型。

- 升级操作为整数集合带来了操作上的灵活性 ，井且尽可能地节约了 内存。
- 整数集合只支持升级操作 ，不支持降级操作 。

## 压缩列表

压缩列表 （ ziplist ） 是列表键和哈希键的底层实现之 一。当一个列表键只包含少量 列表项 ，并且每个列表项要么就是 小整数值 ，要么就是长度比较短的字符串 ，那么 Redis 就 会使用压缩列表来做列表键的底层实现。

### 压缩表的底层实现

压缩列表是一种为节约内存而开发的顺序型数据结构 。

压缩表包含属性：
|属性名|长度|用途|
|---|---|---|
|zlbytes|4字节|记录整个压缩列表占用的内存字节数，对压缩列表进行内存重分配的时候使用|
|zltail|4字节|记录压缩列表尾节点距离起始地址有多少字节|
|zllen|2字节|记录了压缩列表包含的节点数量|
|entryX|不定|压缩列表包含的各个节点|
|zlend|1字节|特殊值0xFF，用于标记压缩列表的末端|

**压缩列表节点构成**：

previous_entry_length|encoding|content

previous_entry_length：表示前一个节点的长度，压缩列表从后像前遍历，可以计算前一个节点的起始地址。（造成连锁更新的关键）

- 如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值
- 如果前一节点的长度大于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值
encoding:其两位表示类型，后6位表示长度

- 压缩列表被用作列表键和哈希键的底层实现之一 。
- 压缩列表可以包含多个节点 ，每个节点可以保存一个字节数组或者整数值 。
- 添加新节点到压缩列表 ，或者从压缩列表中删除节点 ，可能会引发连锁更新操作， 但这种操作出现的几率并不高。
