# Redis高可用Sentinel和Cluster

## 复制

在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为主服务器，而对主服务器进行复制的服务器则被称为从服务器，进行复制中的主从服务器双方的数据库将保存相同的数据，概念中将这种现象称为“数据库状态一致”。

复制命令 `SLAVEOF master_ip master_port`

### 旧版复制功能实现

Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：

- 同步操作用于将从服务器的状态更新至主服务器的状态
- 命令传播操作则用于在主服务器的数据库状态被修改，导致从服务器的数据库状态出现不一致是，让主从服务器的状态重新回到一致。

#### 同步

当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先要执行同步操作。

同步操作中，从服务器需要向主服务器发送SYNC命令,SYNC命令的执行步骤如下：
1> 从服务器向主服务器发送SYNC
从服务器向主服务器发送 SYNC 命令。
2> 收到 SYNC 命令的主服务器执行 BGSAVE 四命令，在后台生成一个 RDB  文件 ，并使 用一个缓冲区记录从现在开始执行的所有写  命令。
3> 当主服务器的 BGSAVE 命令执行完毕时 ，主服务器会将 BGSAVE 命令生成的 RDB 文件发送给从服务器 ，从服务器接收并载入这个 RDB 文件，将自己的数据库状态更新至主 服务器执行 BGSAVE 命令时的数据库状态 。
4> 主服务器将记录在缓冲区里面的所有写命令发送给从服务器 ，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态

#### 旧版复制功能的缺陷

对于初次复制来说，旧版复制功能能够很好的完成任务，但对于断线后重复制，旧版复制功能虽然也能完成任务，让主从服务器重新回到一致状态，但效率却非常低（重新生成RDB文件）；命令丢失，主服务器也不会注意到

### 新版复制功能

新版复制（2.8以后），PSYNC命令具有完整重同步和部分重同步两种模式：

- 其中完整重同步用于处理初次复 制情况 ：完整重同步的执行步骤和 SYNC 命令的执 行步骤基本一样 ，它们都是通过让主服务器创建并发送 RDB 文件 ，以及向从服务器 发送保存在缓冲区里面的写命令来进行同步
- 而部分重同步则用于处理断线后重复制情况  ：当从服务器在断线后 重新连接主服务 器时 ，如果条件允许 ，**主服务器可以将主从服务器连接断开期间执行的写命令发送 给从服务器 **，从服务器只要接收并执行这些写命令  ，就可以将数据库更新至主服务 器当前所处的状态。

部分重同步功能由以下三个部分构成 ：

- 主服务器的复制偏移量 （ replication offset ） 和从服务器的复制偏移量 。
- 主服务器的复制积压缓冲区 （ replication backlog ）。
- 服务器的运行 ID ( run ID ）

#### 复制偏移量

通过对比主从服务器的复制偏移量 ，程序可以很容易地知道主从服务器是否处于一致状态 ： 口 如果主从服务器处于一致状态 ，那么主从服务器两者的偏移量总 是相同的。
口 相反 ，如果主从服务器两者的偏移量并不相同 ，那么说明主从服务器并未处于 一致 状态

#### 复制积压缓冲区

复制积压缓冲区是 由主服务器维护的一个**固定长度** （ fixed-size ） 先进先出 （ FIFO ） 队 列 ，默认大小为  I MB

当从服务器重新连上主服务器时 ，从服务器会通过 PSYNC 命令将自己 的复制偏移量 o f f set 发送给主服务器 ，主服务器会根据这个复 制偏移量来决定对从服务器执行何种同步 操作 ：

- 如果 o f f set 偏移量之后的数据 （ 也即是偏移量 o f f set+ l 开始的数据 ） 仍然存在 于复制积压缓冲区里面 ，那么主服务器将对从服务器执行 部分重同步操作 。
- 相反 ，如果 of f set 偏移量之后的数据已经不存在于复制积压缓冲区 ，那么主服务 器将对从服务器执行完整重同步操作 。

> 复制积压缓冲区的最小大小可以根据公式  second * write_size_per_second来估算，稳妥起见应乘以2

#### 服务器运行ID

除了复制偏移量和复制积压缓冲区之外 ，实现部分重同步还需要用到服务器运行 ID ( run lD ) :

- 每个 Red is 服务器 ，不论主服务器还是从服务 ，都会有自己的运行 ID。
- 运行 ID 在服务器启动时自动生成 ，由 40 个随机的十六进制字符组成 ，例如 53b 9b 2 8df 8 0 4 2 f dc 9ab5e3f cbbbab f fld5dce2b3 o
当从服务器对主服务器进行初次复制时 ，主服务器会将自己的 运行 D传送给从服务器 ，
而从服务器则会将这个运行  ID  保存起来。

当从服务器断线并重新连上一个主服务器时 ，从服务器将向当前连接的主服务器发送之 前保存的运行 ID:

- 如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID 相同 ， 那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作 。
- 相反地 ，如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID 并不相同 ， 那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作 。

#### PSYNC命令

PSYNC 命令的调用方法有两种 ：

- 如果从服务器以前没有复制过任何主 服务器 ，或者之前执行过 SLAVEOF n o one 命令 ，那么从服务器在开始一次新的复制时将向主服务器发送  PSYNC?    -1 命令 ， 主动请求主服务器进行完整重同步 （ 因为这时不可能执行部分重同步 ）。
- 相反地 ，如果从服务器已经复制过某个主服务器 ，那么从服务器在开始一次新的复 制时将向主服务器发送 PSYNC < r u n id> <offset> 命令 ：其中 ru n id 是上一次 复制的主服务器的运行 ID ，而 of f set 则是从服务器当前的复制偏移量 ，接收到这 个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作  。
  
根据情况 ，接收到 PSYNC  命令的主服务器会向从服务器返回 以下三种回复的其中一种：

- 如果主服务器返回 ＋FULLRESYNC < r u n id>  ＜of f set＞ 回复，那么表示主服务
器将与从服务器执行完整重同步操作 ：其中 runid 是这个主服务器的运行 田，从 服务器会将这个 ID 保存起来 ，在下一次发送PSYNC 命令时使用 ；而offset 则是 主服务器当前的复制偏移量 ，从服务器会将这个值作为自己的初始化偏移量。

- 如果主服务器返回 ＋CONTINUE  回复，那么表示主服务器将与从服务器执行部分 重 同步操作，从服务器只要等着主服务器将自己缺少 的那部分数据发送过来就可以了 。
- 如果主服务器返回 ERR 回复，那么表示主服务器的版本低于Redis 2.8 ，它识别不 了 PSYNC 命令 ，从服务器将向主服务器发送SYNC 命令 ，并与主服务器执行完整同 步操作。

#### 复制的完整流程

1. 设置主服务器的地址和端口
2. 建立套接字连接
3. 发送PING命令确认主服务器读写状态是否正常，能否正常处理命令请求
4. 身份验证，从服务器发送 `masterauth <password>` 命令，password和主服务器的 requirepass选项比对
5. 从服务器发送端口信息 `REPLCONF listening-port <port-number>`,向主服务器发送从服务器的监听端口
6. 同步 从服务器将向主服务器发送PSYNC
7. 命令传播

#### 心跳检测

在命令传播阶段，从服务器以每秒一次的频率向主服务器发送命令
`REPLCONF ACK <replication_offset>`

该命令作用如下：

1. 检测主从服务器的网络连接状体
2. 辅助实现min-slaves选项
3. 检测命令丢失

## Sentinel

Sentinel是Redis的高可用解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的从服务器，当被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

当 serve r l的下线时长超过用户设定 的下线时长上限时，Sentinel 系统就 会对
serve r l 执行故障转移操作 ：

- 首先 ，Sentinel 系统会挑选 serverl 属下的其中1个从服务器 ，并将这个被选中的 从服务器升级为新的主服务器 。
- 之后 ，Sentinel 系统会向 serverl 属下的所有从服务器发送新的复制指令 ，让它们 成为新的主服务器的从服务器 ，当所有从服务器都开始复制新的主服务器时 ，故障 转移操作执行完毕 。
- 另外 ，Sentinel 还会继续监视已下线的 serverl ，并在它重新上线时 ，将它设置为 新的主服务器的从服务器。

当一个 Sentinel 启动时 ，它需要执行以下步骤 ：
I） 初始化服务器 。
2 ） 将普通 Redis  服务器使用的代码替换成 Sentinel  专用代码。
3 ） 初始化 Sentinel 状态。
4 ） 根据给定的配置文件 ，初始化 Sentinel 的监视主服务器列表 。
5 ） 创建连向主服务器的网络连接，会创建一个命令连接和订阅连接
> Sentinel服务器会以每10s一次的频率向主服务器发送info命令来获取主服务器的信息（角色、runId（runId每次重启会不同）等），以及主服务器的从服务器信息。同样会以向从服务器创建命令连接和订阅连接

通过Info命令，Sentinel会提取以下信息：

- 从服务器的运行ID runid。
- 从服务器的角色 role
- 主服务器的 IP 地址 master_host ，以及主服务器的端口号 master_port 
- 主从服务器的连接状态 master_link_status。
- 从服务器的优先级 slave_priority 。
- 从服务器的复制偏移量 slave_repl_offset 。

向主服務器發送信息：
Sentinel会以两秒一次的频率，通过命令连接向所有被监视的主服务器和送服务器发送自己的信息和监视的主服务器信息。

publish _sentinel_:hello "<s_ip> , <s_po r t > , <s_ ru n id> , <s_epoch> , <m_ name> , <m_ip> , <m_port> , <m_epoch＞"

接收来自主服务器和从服务器的频道信息:

对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其它Sentinel接收到，这些信息会被用于更新其它Sentinel对发送Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。

监视同一个主服务器的多个Sentinel可以自动发现对方。

当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建响应的实力结构，还会创建一个连向新Sentinel的命令连接，最终监视同一个主服务器的Sentinel会形成互相连接的网络。

主观下线：

在默认情况下 ，Sentinel 会以每秒一次的频率向所有与它创建 了命令连接的实例 （ 包括 主服务器 、从服务器 、其他 Sentinel 在内） 发送 PING 命令 ，并通过实例返回的 PING 命令回复来判断实例是否在线 。

客观下线：当 Sentinel 从其他 Sentinel 那里接收 到足够数量的已下线判断之后 ，Senti.net 就会将从服务器判定为客观下线 ，并对主服务器执 行故障转移操作 。

>Sentinel 使用：
`SENTINEL  is-master-down-by -addr  <ip>  <po rt>  <cu rren t_epoch>  <runid>`
命令询问其他 Sentinel 是否同意主服务器已下线

根据其他 Sentinel 发回的 SENT INEL is-master-down-by-addr 命令回复 ，Sentinel 将统计其他 Sentinel 同意主服务器己下线的数量(quorom) ，当这一数量达到配置指定的判断客观下线 所需的数量时 ，Sentinel 会将主服务器实例结构 f lags 属性的 SR_I_O_DOWN 标识打开 ，表 示主服务器已经进入客观下线状态.

选举领头Sentinel

配置纪元（epoch）：每次进行领头选举，不论选举是否成功，所有Sentinel的配置纪元都会自增一。
所有的Sentinel都有一次将某个Sentinel设置为局部领头Sentinel
的机会，并且一旦设置，在这个配置纪元里就不能更改。

Sentinel设置局部领头Sentinel的规则是先到先得，最先向目标Sentinel发送设置要求的源Sentinel将称为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。

目标 Sentinel 在接收到 SENT 工NEL is-ma ste r-dow n -by-add r 命令之后 ，将向 游、Sentinel 返回一条命令回复 ，回复中的 leade r r u n id 参数和 leade r epoch 参数分别记录了目标 Sentinel 的局部领头 Sentinel 的运行 田和配置纪元。

源 Sentinel 在接收到目标 Sentinel 返回的命令回复之后 ，会检查回复中leader epoch 参数的值和自己的配置纪元是否相同 ，如果相同的话 ，那么源 Sentinel 继续 取出回复中的 lea der  r u n id 参数 ，如果 leader  r un id 参数的值和源 Sentinel 的运行 ID致 ，那么表示目标 Sentinel 将源 Sentinel 设置成了局部领头 Sentinel 。

如果有某个 Sentinel 被半数以上的 Sentinel 设置成了局部领头 Sentinel ，那么这个 Sentinel 成为领头 Sentinel 。

因为领头 Sentinel 的产生需要半数以上 Sentinel 的支持 ，并且每个 Sentinel 在每个 配置纪元里面只能设置一次局部领头 Sentinel ，所以在一个配置纪元里面，只会出现 一个领头 Sentinel。

如果在给定时限 内，没有一个 Sentinel 被选举为领头 Sentinel ，那么各个 Sentinel 将 在一段时间之后再次进行选举 ，直到选出领头 Sentinel 为止。

故障转移：
在选举产生出领头 Sentinel 之后 ，领头 Sentinel 将对已下线的主服务器执行故障转移 操 作 ，该操作包含以下三个步骤 ：
l） 在已下线主服务器属下的所有从服务器里面 ，挑选出一个从服务器 ，并将其转换为 主服务器。
2 ） 让己下线主服务器属 下的所有从服务器改为复制新的 主服务器。
3 ）  将已下线主服务器设置为新的主服务器的从服务器 ，当这个旧的主服务器重新上线 时，它就会成为新的主服务器的从服务器

>新的主服务器选取规则： 优先级>复制偏移量>运行ID
>主服务器选好后Sentinel会向新的主服务器发送Slave no one，向从服务器发送slave of m_ip m_port

## Cluster

Redis 集群是 Reclis 提供的分布式数据库方案 ，集群通过分片 （ sharding ） 来进行数据共享 ，并提供复制和故障转移功能。

### 节点

一个 Red is 集群通常由多个节点 （ node ） 组成，在刚开始的时候，每个节点都是相互独 立的 ，它们都处于一个只包含自己的集群当中 ，要组建一个真正可工作的集群 ，我们必须将 各个独立的节点连接起来 ，构成一个包含多个节点的集群。

向一个节点 node 发送 CLUSTER MEET 命令 ，可以让 node 节点与 ip 和 por t 所指定 的节点进行握手 （ handshake ），当握手成功时 ，node 节点就会将 ip 和 po r t 所指定的节点 添加到 node 节点当前所在 的集群中

> 打开集群配置：`cluster-enabled:yes`
> 使用命令`cluster meet <ip> <port>`将节点纳入集群

### 槽指派

Redis 集群通过分片的方式来保存数据库中的键值对 ：集群的整个数据库被分为 16384 个槽 （ slot ），数据库中的每个键都属于这 16384 个槽的其中一个 ，集群中的每个节点可以处 理 0 个或最多 16384 个槽。

当数据库中的 16384 个槽都有节点在处理时 ，集群处于上线状态 （ ok ） ；相反地 ，如果 数据库中有任何一个槽没有得到处理 ，那么集群处于下线状态 （ fail ）。

### 在集群钟执行命令

在对数据库中的 16384 个槽都进行了指派之后 ，集群就会进入上线状态 ，这时客户端就 可以向集群中的节点发送数据命令了 。

当客户端向节点发送与数据库键有关的命令时  ，接收命令的节点会计算出命令要处理的 数据库键属于哪个槽 ，并检查这个槽是否指派给了自己  ：
口 如果键所在的槽正好就指派给了当前节点 ，那么节点直接执行这个命 令。
口 如果键所在的槽并没有指派给当前节点 ，那么节点会向客户端返回一个 `MOVED <slot> <ip>:<port>` 错 误 ，指引客户端转向 （ redirect ） 至正确的节点 ，井再次发送之前想要执行 的命令。

> 计算键属于哪个槽：slot = CRC16(key)&16383
> 可使用：`cluster keyslot <key>`查看key属于哪个槽
> ps:客户端分为单机模式和集群模式，单机模式无法识别MOVED错误
> ps:集群模式只能使用0号数据库

### 重新分片

Redis 集群的重新分片操作可以将任意数量已经指派给某个节点 （ 源节点 ） 的槽改为指 派给另一个节点 （ 目标节点 ），并且相关槽所属的键值对也会从源节点被移动到目 标节点。
 重新分片操作可以在线 （ online ） 进行 ，在重新分片的过程中 ，集群不需要下线 ，并且源节点和目标节点都可以继续处理命令请求 。

 > 在迁移过程中，访问的键如果正在迁移到其它节点，会返回ASKING错误

### 复制和故障转移

#### 故障转移
集群中的每个节点都会定期地向集群中地其它节点发送PING消息，以此来检测对方是否在线，如果接收PING消息地节点没有在规定地时间内，向发送PING消息地节点返回PONG消息，那么发送PING消息地节点就会将接收PING消息地节点标记为疑似下线。

如果在一个集群里面 ，半数以上负责处理槽的主节点都将某个主节点 x 报告为疑似下线 ， 那么这个主节点 x 将被标记为己下线 （ FAIL ），将主节点 x 标记为已下线的节点会向集群广播 一条关于主节点 x 的 FAIL 消息 ，所有收到这条 FA IL 消息的节点都会立即将主节点 x 标记 为已下线

故障转移的执行步骤 ：
1 ） 复制下线主节点的所有从节点里面 ，会有一个从节点被选中 。
2 ） 被选中的从节点会执行 SLAVEOF no one 命令 ，成为新的主节点 。
3 ） 新的主节点会撤销所有对已下线主节点的槽指派 ，并将这些槽全部指派给自己 。
4 ） 新的主节点向集群广播一条 PONG 消息 ，这条 PONG 消息可以让集群中的其他节点 立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负 责处理的槽。
5 ） 新的主节点开始接收和自己负责 处理的槽有关的命令请求 ，故障转移完成 。

以下是集群选举新的主节点的方法 ：
l ） 集群的配置纪元是一个自增计数器 ，它的初始值为 0。
2 ） 当集群里的某个节点开始一次故障转移操作时 ，集群配置纪元的值会被增一 。
3 ） 对于每个配置纪元 ，集群里每个负责处理槽 的主节点都有一次投票的机会 ，而第一 个向主节点要求投票的从节点将获得主节点的投票 。
4 ） 当从节点发现自己正在复制的主节点进入己下线状态时 ，从节点会向集群广播一条
CLUSTE RMSG  TY PE  FA I LOVER  AUTH  REQUEST 消息 ，要求所有收到这条消息 、并且具有投票权的主节点向这个从节点投票 。
5 ） 如果一个主节点具有 投票权 （ 它正在负责处理槽 ），并且这个主节点尚未 投票给其 他从节点 ，那么主节点将向要求投票的从节点返回一条 C LUSTE RMSG    TY PE    FAILOVER AUTH    ACK  消息 ，表示这个主节点支持从节点成为新的主节点 。
6 ） 每个参与选举 的从节点都会接收 CLUSTERMSG  TYPE  FA I LOVER  AUTH  ACK 消 息，并根据自己收到了 多少条这种消息来统计自己获得了多少主节点的支持  。
7 ） 如果集群里有 N 个具有投票权的主节点 ，那么当一个从节点收集到大于等于 N/2+1
张支持票时 ，这个从节点就会当选为新的主节点 。
8 ）  因为在每一个配置纪元里面 ，每个具有投票权的主节点只 能投一次票 ，所以如果有
N 个主节点进行投票 ，那么具有大于等于 N/2+1 张支持票的从节点只会有一个 ，这确保了新 的主节点只会有一个。
9 ） 如果在一个配置纪元里面没有从节点能收集到足够多的支持票 ，那么集群进入一个 新的配置纪元 ，并再次进行选举 ，直到选出新的主节点为止 。
这个选举新主节点的方法和第  16 章介绍的选举领头 Sentinel   的方法非常相似 ，因为两 者都是基于 Raft 算法的领头选举 （ leader election ） 方法来实现的 。


## 基于Raft算法的选举
