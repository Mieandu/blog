# Redis

- **优点**：
1.速度快
2.支持丰富的数据类型
3.丰富的特性
订阅发布
key过期策略
事务
支持多个db
4.持久化
5.高可用
- **缺点**
 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务
  
## 持久化

- **RDB**：
冷备，恢复快，性能最大化（fork子进程之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了）
- **AOF**：
更高的数据安全性；append模式，速度快，出现宕机也不会影响已有的内容；
aof记录的是所有的修改操作

**RDB和AOF的选择**：

bgsave 做镜像全量持久化（从），AOF 做增量持久化(主，从也可以)。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使**用 bgsave 持久化文件**重新构建内存，再使**用 AOF 重放近期的操作指令**来实现完整恢复重启之前的状态。

> bgsave 操作后，会产生 RDB 快照文件
> 为什么不建议在主节点开启RDB？
> 子进程 fork 相关的阻塞；内存相关的阻塞；CPU 单线程相关的阻塞，如果显示绑定了CPU ，则子进程会与主进程共享一个 CPU（持久化则不要绑定CPU）；磁盘相关的阻塞（内存不够的情况）

## 过期策略

懒过期；

定期过期：Redis周期性的调用activeExpireCycle函数，它在规定的时间内，分多次遍历服务器中的各个数据库，会遍历所有数据库，随机选择一部分键检测是否过期

AOF、RDB和复制功能对过期键的处理：

RDB：
生成RDB文件，在生成RDB文件时，如果键已经过期，过期的键不会保存到RDB文件中。
载入RDB：如果时主服务器，会过滤掉过期的键，如果是从服务器，无论键是否过期，都会被载入

AOF 文件写入：当过期键被删除之后，会追加一个条Del命令来删除key以显示删除记录

AOF重写：在重写的过程中，程序会对数据库进行检查，已过期的键不会保存到重写后的AOF文件中。

复制：从服务器不会删除过期键，（当有命令时，键即使过期也会正常返回），除非收到主服务器同步过来的删除命令

## 淘汰策略

Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。

Redis 提供了 6 种数据淘汰策略：

1. volatile-lru
1. volatile-ttl
1. volatile-random
1. allkeys-lru
1. allkeys-random
1. 【默认策略】no-enviction

在 Redis 4.0 后，基于 LFU（Least Frequently Used）最近最少使用算法，增加了 2 种淘汰策略：

1. volatile-lfu
1. allkeys-lfu

## Redis实现分布式锁的方案

1.单机 setnx
2.多机 使用redlock算法

>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。
>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。

## Redis 有哪些数据结构

如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：

字符串 String
字典Hash
列表List
集合Set
有序集合 SortedSet
如果你是 Redis 中级玩家，还需要加上下面几种数据结构：

HyperLogLog
Geo
Bitmap
如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：

BloomFilter
RedisSearch
Redis-ML
JSON
另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。

### Redis为什么这么快的另类解释

**面试官**：redis作为缓存大家都在用，那redis一定很快咯？

**我**：当然了，官方提供的数据可以达到100000+的QPS（每秒内的查询次数），这个数据不比Memcached差！

**面试官**：redis这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）

**我**：您是想问Redis这么快，为什么还是单线程的吧。Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。

**面试官**：嗯，是的。那你能说说Redis是单线程的，为什么还能这么快吗？

**我**：可以这么说吧。第一：Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。第二：数据结构简单，对数据操作也简单。第三：采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。第四：使用多路复用IO模型，非阻塞IO。
